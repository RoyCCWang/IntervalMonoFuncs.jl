var documenterSearchIndex = {"docs":
[{"location":"citation.html#Citation","page":"License","title":"Citation","text":"","category":"section"},{"location":"citation.html","page":"License","title":"License","text":"If you use IntervalMonoFuncs.jl in a report or journal article, please kindly cite this repository using the GitHub citation option on the main repository webpage.","category":"page"},{"location":"citation.html#License","page":"License","title":"License","text":"","category":"section"},{"location":"citation.html","page":"License","title":"License","text":"IntervalMonoFuncs.jl is available under the Mozilla Public License V2 (MPL2). see the LICENSE file in the repository root for the full license. For more information on the MPL2 license, please see the MPL 2.0 FAQ webpage from Mozilla, the creators of the MPL2 license.","category":"page"},{"location":"citation.html","page":"License","title":"License","text":"If you use this package as a dependency or modified it to include in your public/private/commericial product, please disclose the use this package and the copyright of this package in an external dependencies or third party license file for your product. This license file should be in the public domain. An example of such a disclosure file can be found in the THIRDPARTY.md file in the root Julia programming language repository.","category":"page"},{"location":"reference.html#Function-References","page":"Public API","title":"Function References","text":"","category":"section"},{"location":"reference.html","page":"Public API","title":"Public API","text":"getpiecewiselines","category":"page"},{"location":"reference.html#IntervalMonoFuncs.getpiecewiselines","page":"Public API","title":"IntervalMonoFuncs.getpiecewiselines","text":"getpiecewiselines( intervals_y_st::Vector{T},\n    intervals_y_fin::Vector{T},\n    domain_proportion::T;\n    lb::T = -one(T),\n    ub::T = one(T))\n\nReturns (in order):\n\ninfo::Piecewise2DLineType{T}\nscale::T\n\nComputes the parameters (contained in info) of a piecewise-linear function. intervals_y_st and intervals_y_fin specify the starting and finishing y coordinates of line segments in the piecewise-linear function. The boundary points of the specified interval are automatically accounted for if they are not in intervals_y_st and intervals_y_fin.\n\nInput constraints:\n\n0 < domain_proportion < 1.\nintervals_y_st[k] < intervals_y_fin[k] for any valid index k of intervals_y_st and intervals_y_fin. See checkzstfin() for a function that checks this condition.\n\nExample use of info and scale.\n\nf = xx->evalpiecewise2Dlinearfunc(xx, info, scale)\nfinv = yy->evalinversepiecewise2Dlinearfunc(yy, info, scale)\n\nf is an anonymous function that takes a value from the interval [lb, ub] to a value in [lb, ub]. It mathematically implements the piecewise-linear function created by getpiecewiselines(). finv is an anonymous function that implements the mathematic inverse of f.\n\nExample\n\njulia> intervals_y_st = [-0.82; 0.59];\n\njulia> intervals_y_fin = [0.044; 0.97];\n\njulia> lb = -2.0;\n\njulia> ub = 1.0;\n\njulia> domain_proportion = 0.9;\n\njulia> info, scale = getpiecewiselines(intervals_y_st, intervals_y_fin, domain_proportion; lb = lb, ub = ub)\n(Piecewise2DLineType{Float64}([-1.0, -0.8992027334851938, 0.03841784529294124, 0.08505793640911433, 0.4974373576309793, 0.5], [-1.0, -0.41, 0.022, 0.295, 0.485, 0.5], [5.853333333333337, 0.46074074074074073, 5.853333333333337, 0.4607407407407408, 5.853333333333337], [4.853333333333337, 0.004299333502067071, -0.20287245444801622, 0.2558103433729858, -2.4266666666666685], [0.9376205787781351, 0.41237942122186494], [0.432, 0.19]), 2.0)\n\njulia> _, _, boundary_pts = getboundarypts(intervals_y_st, intervals_y_fin, lb, ub, info, scale);\n\njulia> boundary_pts\n6-element Vector{Tuple{Float64, Float64}}:\n (-2.0, -2.0)\n (-1.7984054669703875, -0.82)\n (0.07683569058588248, 0.044)\n (0.17011587281822874, 0.59)\n (0.9948747152619589, 0.97)\n (1.0, 1.0)\n\nSee /examples/piecewise_linear.jl for the full example.\n\n\n\n\n\n","category":"function"},{"location":"reference.html","page":"Public API","title":"Public API","text":"checkzstfin","category":"page"},{"location":"reference.html#IntervalMonoFuncs.checkzstfin","page":"Public API","title":"IntervalMonoFuncs.checkzstfin","text":"checkzstfin(intervals_y_st::Vector{T}, intervals_y_fin::Vector{T}) where T <: Real\n\nReturns true if intervals_y_st and intervals_y_fin are valid inputs as intervals_y_st and intervals_y_fin for getpiecewiselines().\n\n\n\n\n\n","category":"function"},{"location":"reference.html","page":"Public API","title":"Public API","text":"evalpiecewise2Dlinearfunc","category":"page"},{"location":"reference.html#IntervalMonoFuncs.evalpiecewise2Dlinearfunc","page":"Public API","title":"IntervalMonoFuncs.evalpiecewise2Dlinearfunc","text":"evalpiecewise2Dlinearfunc(x::T, A::Piecewise2DLineType{T}, scale::T)::T where T <: Real\n\nEvaluates the piecewise-linear function with parameters contained in A and scale at input x.\n\nObtain info and scale from getpiecewiselines().\n\n\n\n\n\n","category":"function"},{"location":"reference.html","page":"Public API","title":"Public API","text":"evalinversepiecewise2Dlinearfunc","category":"page"},{"location":"reference.html#IntervalMonoFuncs.evalinversepiecewise2Dlinearfunc","page":"Public API","title":"IntervalMonoFuncs.evalinversepiecewise2Dlinearfunc","text":"evalinversepiecewise2Dlinearfunc(y::T, A::Piecewise2DLineType{T}, scale::T)::T where T <: Real\n\nEvaluates the inverse of the piecewise-linear function f at input y, where f has parameters that are contained in A and scale.\n\nObtain info and scale from getpiecewiselines().\n\n\n\n\n\n","category":"function"},{"location":"reference.html","page":"Public API","title":"Public API","text":"createendopiewiselines1","category":"page"},{"location":"reference.html#IntervalMonoFuncs.createendopiewiselines1","page":"Public API","title":"IntervalMonoFuncs.createendopiewiselines1","text":"infos, zs, p_range = createendopiewiselines1(p_lb::T,\n        p_ub::T,\n        range_proportion::T;\n        N_itp_samples::Int = 10,\n        domain_proportion::T = 0.9) where T <: Real\n\nGet the parameters for a set of N_itp_samples two-segment piecewise-linear functions. One of the segments is referred to as the focus interval. The inputs range_proportion and range_proportion specifies the properties of the focus interval/line segment for each constructed piecewise-linear function in the returned set.\n\nThe focus intervals of each function is recorded in p_range. They are evenly spaced between p_lb + range_proportion/2 and p_ub - range_proportion/2.\n\nInputs:\n\np_lb::T: lower bound for the domain and range for each function.\np_ub::T: upper bound for the domain and range for each function. Constraint: -one(T) <= p_lb < p_ub <= one(T).\nrange_proportion::T: The proportion of the range for each function's focus interval. Takes a value between 0 and 1.\nN_itp_samples::Int: The number of functions to fit,\ndomain_proportion::T: The proportion of the domain for each function's focus interval. Takes a value between 0 and 1.\n\nOutputs\n\ninfos::Piecewise2DLineType{T}: an internal datatype for use with evalpiecewise2Dlinearfunc() to evaluate the generated piecewise-linear functions.\n\nFor example, the following creates an anonymous function for the m-th piecewise-linear function:\n\ninfo = infos[m]\nf = xx->evalpiecewise2Dlinearfunc(xx, info)\nf_evals = f.(LinRange(p_lb, p_ub, 200))\n\nNote the usual scale input to evalpiecewise2Dlinearfunc() is not required for the piecewise-linear functions returned by createendopiewiselines1().\n\nzs::Vector{Vector{T}}: For a given index m in zs, \n\nfirst(zs[m]) is the range coordinate of the start of the focus interval for the m-th piecewise-linear function. last(zs[m]) is the range coordinate of the end of the focus interval for the m-th piecewise-linear function.\n\nDo the following to the get boundary points of the piecewise-linear function.\n\nintervals_y_st = [first(zs[m]);]\nintervals_y_fin = [last(zs[m]);]\nstart_pts, fin_pts, boundary_pts = IntervalMonoFuncs.getboundarypts(intervals_y_st, intervals_y_fin, lb, ub, infos[m], 1.0)\n\np_range::LinRange{T,Int}: p_range[m] is the range coordinate of the center of the focus interval for the m-th function.\n\nSee /examples/fit_logistic-logit.jl in the package repository and the repository document website for other examples.\n\n\n\n\n\n","category":"function"},{"location":"reference.html","page":"Public API","title":"Public API","text":"getlogisticprobitparameters","category":"page"},{"location":"reference.html#IntervalMonoFuncs.getlogisticprobitparameters","page":"Public API","title":"IntervalMonoFuncs.getlogisticprobitparameters","text":"getlogisticprobitparameters(infos::Vector{Piecewise2DLineType{T}},\n    runoptimfunc::Function;\n    N_fit_positions::Int = 15,\n    a_lb::T = 0.1,\n    a_ub::T = 0.6,\n    b_lb::T = -5.0,\n    b_ub::T = 5.0,\n    a_initial = (a_ub-a_lb)/2,\n    b_initial = (b_ub-b_lb)/2) where T <: Real\n\nGiven a set of single-focus interval region piecewise-linear functions' parameters (collectively contained in info), fit the a and b parameters of the logistic-probit function (see evalcompositelogisticprobit) for each piecewise-linear function.\n\nInputs\n\ninfos: obtained from createendopiewiselines1().\nrunoptimfunc: This function runs an optimization routine that the user must supply.\n\nIntervalMonoFuncs.jl does not currently ship with any optimization routines, nor does it use third party optimization routines as dependencies. This is done so that the user can have more flexibility to choose the optimization package and tuning parameters.\n\nrunoptimfunc should be in the following form:\n\nrunoptimfunc = (pp0, ff, dff, pp_lb, pp_ub)->runoptimroutine(pp0, ff, dff, pp_lb, pp_ub, other_args...)\n\nwhere runoptimroutine() is the user-supplied routine for invoking their box-constrained numerical minimization code of choice. The other optimization package-specific tuning parameters can go where other_args... is. runoptimfunc() should return a Vector{T} that contains the solution to the numerical minimization of ff.\n\nThe pp0::Vector{T} input slot is the optimization variable initial guess slot. the ff::Function slot is for the cost function, It should be such that ff(pp0) is the cost associated with the initial guess. the dff::Function slot is for the gradient of the cost function, It should be such that dff(pp0 is the gradient of the cost function evaluated at the initial guess, but one can assign it any function (such as the identity xx->xx) if they are not using a gradient-based optimization algorithm in their runoptimfunc(). the pp_lb::Vector{T} slot is for the lower bounds of the optimization variable, the pp_ub::Vector{T} slot is for the upper bounds of the variable.\n\nrunoptimfunc() must return a 1D array of type Vector{T}, where T = eltype(pp0).\n\nThere are examples on how to create a valid runoptimfunc on the repository documentation website and in /examples/fit_logistic-logit.jl.\n\nOptional inputs:\n\nNfitpositions: The number of fit positions used in the optimization.\na_lb: lower bound used for optimizing a\na_ub: lower bound used for optimizing a\nb_lb: lower bound used for optimizing b\nb_ub: lower bound used for optimizing b\na_initial: initial guess for a\nb_initial: initial guess for b\n\nOutputs (in order):\n\ncostfuncs::Vector{Function}: the costfunction used to optimize each logistic-probit function against its corresponding piecewise-linear function.\nminxs::Vector{Vector{T}}: 1-D array of solution arrays.\n\nfirst(minxs[m]) is the optimized a variable for the m-th logistic-probit function. last(minxs[m]) is the optimized b variable for the m-th logistic-probit function.\n\nUsage for minxs: The following creates a vector of functions, each implements a fitted logistic-probit function.\n\nqs = collect( tt->IntervalMonoFuncs.evalcompositelogisticprobit(tt, first(minxs[i]), last(minxs[i])) for i in eachindex(minxs) )\n\n\n\n\n\n","category":"function"},{"location":"reference.html","page":"Public API","title":"Public API","text":"evalcompositelogisticprobit","category":"page"},{"location":"reference.html#IntervalMonoFuncs.evalcompositelogisticprobit","page":"Public API","title":"IntervalMonoFuncs.evalcompositelogisticprobit","text":"evalcompositelogisticprobit(x::T, a::T, b::T)::T where T <: Real\n\nevaluates the map from (0,1) to (0,1). returns 1/(1 + exp(-a*(log(x/(1-x))-b)))\n\nSome numerical stability issues when the magnitudes of a or b is larger than 2 when T = Float64. See /examples/logistic-probit.jl for an example of stability test in the root package directory.\n\n\n\n\n\nevalcompositelogisticprobit(x_inp::T, a::T, b::T, lb::T, ub::T)::T where T <: Real\n\nApplies the following:\n\nTransforms y from [lb,ub] to (0,1).\nevaluates the map, 1/(1 + exp(-a*(log(x/(1-x))-b))), which transforms a value from (0,1) to (0,1).\ntransforms the evaluated map value from (0,1) to [lb,ub], and returns the result.\n\nSome numerical stability issues when the magnitudes of a or b is larger than 2 when T = Float64. See /examples/logistic-probit.jl for an example of stability test in the root package directory.\n\n\n\n\n\n","category":"function"},{"location":"reference.html","page":"Public API","title":"Public API","text":"evalinversecompositelogisticprobit","category":"page"},{"location":"reference.html#IntervalMonoFuncs.evalinversecompositelogisticprobit","page":"Public API","title":"IntervalMonoFuncs.evalinversecompositelogisticprobit","text":"evalinversecompositelogisticprobit(y::T, a::T, b::T)::T where T <: Real\n\nevaluates the map from (0,1) to (0,1). return exp(b)/(exp(b) + (-1 + 1/y)^(1/a))\n\nSome numerical stability issues when the magnitudes of a or b is larger than 2 when T = Float64. See /examples/logistic-probit.jl for an example of stability test in the root package directory.\n\n\n\n\n\nevalinversecompositelogisticprobit(y::T, a::T, b::T)::T where T <: Real\n\nApplies the following:\n\nTransforms y from [lb,ub] to (0,1).\nevaluates the map, exp(b)/(exp(b) + (-1 + 1/y)^(1/a)), which transforms a value from (0,1) to (0,1).\ntransforms the evaluated map value from (0,1) to [lb,ub], and returns the result.\n\nSome numerical stability issues when the magnitudes of a or b is larger than 2 when T = Float64. See /examples/logistic-probit.jl for an example of stability test in the root package directory.\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"This library provides methods to construct transport maps that transform the uniform distribution on an interval to some distribution on the same interval that has mass concentrated in user-specified regions.","category":"page"},{"location":"index.html#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Add (currently) unregistered public Julia package for dependency before installing IntervalMonoFuncs.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(path=\"https://github.com/RoyCCWang/IntervalMonoFuncs.jl\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To update this package once it is installed, do","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pkg.update(\"IntervalMonoFuncs\")","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The following summarizes the usage of the public API:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"getpiecewiselines() constructs piecewise-linear functions from finite intervals on mathbbR to the same interval (an endomorphism in mathematics). The constructed function is a transport map that transforms the uniform distribution over the interval to a piecewise-uniform distribution over the interval. The construction method requires inputs that specify properties of the piecewise-uniform distribution and the endomorphism domain/range interval.\nmethods to evaluate piecewise-linear and a the composition of a logistic and a probit function, and their inverse. A composite function of this type is referred as a logistic-probit function throughout this package. It has domain and range [0,1].\ncreateendopiewiselines1() is similar to getpiecewiselines(), but is designed specifically to generate a family of two-segment piecewise-linear functions. The generated functions are evenly \"spaced/centered\" over the user-specified subintervals in the domain and range. The domain and range is fixed to a subset of [-1,1] in the current version of this package. This creates a transport map that could drastically relocate the mass to a single interval.\ngetlogisticprobitparameters() is a routine to fit the parameters of a logistic-probit function to each family of two-segment piecewise-linear functions generated by createendopiewiselines1(), if the domain and range is set to the interval [0,1]. This creates a smooth version for each of the piecewise-uniform transport maps (each a two-segment piecewise-linear function).","category":"page"},{"location":"index.html#Nomenclature","page":"Home","title":"Nomenclature","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"See our nomenclature page.","category":"page"},{"location":"index.html#Usage-examples","page":"Home","title":"Usage examples","text":"","category":"section"},{"location":"index.html#Julia-examples:","page":"Home","title":"Julia examples:","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"piecewise-linear construction guide: HTML, Jupyter notebook\nlogistic-probit fit and usage guide: HTML, Jupyter notebook","category":"page"}]
}
