<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · IntervalMonoFuncs.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">IntervalMonoFuncs.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="reference.html">Public API</a><ul class="internal"><li><a class="tocitem" href="#Function-References"><span>Function References</span></a></li></ul></li><li><a class="tocitem" href="citation.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reference.html">Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reference.html">Public API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/main/docs_src/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Function-References"><a class="docs-heading-anchor" href="#Function-References">Function References</a><a id="Function-References-1"></a><a class="docs-heading-anchor-permalink" href="#Function-References" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.getpiecewiselines" href="#IntervalMonoFuncs.getpiecewiselines"><code>IntervalMonoFuncs.getpiecewiselines</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpiecewiselines( intervals_y_st::Vector{T},
    intervals_y_fin::Vector{T},
    domain_proportion::T;
    lb::T = -one(T),
    ub::T = one(T))</code></pre><p>Returns (in order):</p><ul><li><code>info::Piecewise2DLineType{T}</code></li><li><code>scale::T</code></li></ul><p>Computes the parameters (contained in <code>info</code>) of a piecewise-linear function. <code>intervals_y_st</code> and <code>intervals_y_fin</code> specify the starting and finishing y coordinates of line segments in the piecewise-linear function. The boundary points of the specified interval are automatically accounted for if they are not in <code>intervals_y_st</code> and <code>intervals_y_fin</code>.</p><p>Input constraints:</p><ul><li><code>0 &lt; domain_proportion &lt; 1</code>.</li><li><code>intervals_y_st[k]</code> &lt; <code>intervals_y_fin[k]</code> for any valid index <code>k</code> of <code>intervals_y_st</code> and <code>intervals_y_fin</code>. See <code>checkzstfin()</code> for a function that checks this condition.</li></ul><p><strong>Example use of <code>info</code> and <code>scale</code>.</strong></p><pre><code class="nohighlight hljs">f = xx-&gt;evalpiecewise2Dlinearfunc(xx, info, scale)
finv = yy-&gt;evalinversepiecewise2Dlinearfunc(yy, info, scale)</code></pre><p><code>f</code> is an anonymous function that takes a value from the interval [<code>lb</code>, <code>ub</code>] to a value in [<code>lb</code>, <code>ub</code>]. It mathematically implements the piecewise-linear function created by <code>getpiecewiselines()</code>. <code>finv</code> is an anonymous function that implements the mathematic inverse of <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; intervals_y_st = [-0.82; 0.59];

julia&gt; intervals_y_fin = [0.044; 0.97];

julia&gt; lb = -2.0;

julia&gt; ub = 1.0;

julia&gt; domain_proportion = 0.9;

julia&gt; info, scale = getpiecewiselines(intervals_y_st, intervals_y_fin, domain_proportion; lb = lb, ub = ub)
(Piecewise2DLineType{Float64}([-1.0, -0.8992027334851938, 0.03841784529294124, 0.08505793640911433, 0.4974373576309793, 0.5], [-1.0, -0.41, 0.022, 0.295, 0.485, 0.5], [5.853333333333337, 0.46074074074074073, 5.853333333333337, 0.4607407407407408, 5.853333333333337], [4.853333333333337, 0.004299333502067071, -0.20287245444801622, 0.2558103433729858, -2.4266666666666685], [0.9376205787781351, 0.41237942122186494], [0.432, 0.19]), 2.0)

julia&gt; _, _, boundary_pts = getboundarypts(intervals_y_st, intervals_y_fin, lb, ub, info, scale);

julia&gt; boundary_pts
6-element Vector{Tuple{Float64, Float64}}:
 (-2.0, -2.0)
 (-1.7984054669703875, -0.82)
 (0.07683569058588248, 0.044)
 (0.17011587281822874, 0.59)
 (0.9948747152619589, 0.97)
 (1.0, 1.0)</code></pre><p>See /examples/piecewise_linear.jl for the full example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/piece_wise_linear.jl#L32-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.checkzstfin" href="#IntervalMonoFuncs.checkzstfin"><code>IntervalMonoFuncs.checkzstfin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">checkzstfin(intervals_y_st::Vector{T}, intervals_y_fin::Vector{T}) where T &lt;: Real</code></pre><p>Returns true if <code>intervals_y_st</code> and <code>intervals_y_fin</code> are valid inputs as <code>intervals_y_st</code> and <code>intervals_y_fin</code> for <code>getpiecewiselines()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/piece_wise_linear.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.evalpiecewise2Dlinearfunc" href="#IntervalMonoFuncs.evalpiecewise2Dlinearfunc"><code>IntervalMonoFuncs.evalpiecewise2Dlinearfunc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evalpiecewise2Dlinearfunc(x::T, A::Piecewise2DLineType{T}, scale::T)::T where T &lt;: Real</code></pre><p>Evaluates the piecewise-linear function with parameters contained in <code>A</code> and <code>scale</code> at input <code>x</code>.</p><p>Obtain <code>info</code> and <code>scale</code> from getpiecewiselines().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/piece_wise_linear.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.evalinversepiecewise2Dlinearfunc" href="#IntervalMonoFuncs.evalinversepiecewise2Dlinearfunc"><code>IntervalMonoFuncs.evalinversepiecewise2Dlinearfunc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evalinversepiecewise2Dlinearfunc(y::T, A::Piecewise2DLineType{T}, scale::T)::T where T &lt;: Real</code></pre><p>Evaluates the inverse of the piecewise-linear function <code>f</code> at input <code>y</code>, where <code>f</code> has parameters that are contained in <code>A</code> and <code>scale</code>.</p><p>Obtain <code>info</code> and <code>scale</code> from <code>getpiecewiselines()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/piece_wise_linear.jl#L235-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.createendopiewiselines1" href="#IntervalMonoFuncs.createendopiewiselines1"><code>IntervalMonoFuncs.createendopiewiselines1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">infos, zs, p_range = createendopiewiselines1(p_lb::T,
        p_ub::T,
        range_proportion::T;
        N_itp_samples::Int = 10,
        domain_proportion::T = 0.9) where T &lt;: Real</code></pre><p>Get the parameters for a set of <code>N_itp_samples</code> two-segment piecewise-linear functions. One of the segments is referred to as the focus interval. The inputs <code>range_proportion</code> and <code>range_proportion</code> specifies the properties of the focus interval/line segment for each constructed piecewise-linear function in the returned set.</p><p>The focus intervals of each function is recorded in <code>p_range</code>. They are evenly spaced between <code>p_lb + range_proportion/2</code> and <code>p_ub - range_proportion/2</code>.</p><p><strong>Inputs:</strong></p><ul><li><code>p_lb::T</code>: lower bound for the domain and range for each function.</li><li><code>p_ub::T</code>: upper bound for the domain and range for each function. Constraint: <code>-one(T) &lt;= p_lb &lt; p_ub &lt;= one(T)</code>.</li><li><code>range_proportion::T</code>: The proportion of the range for each function&#39;s focus interval. Takes a value between 0 and 1.</li><li><code>N_itp_samples::Int</code>: The number of functions to fit,</li><li><code>domain_proportion::T</code>: The proportion of the domain for each function&#39;s focus interval. Takes a value between 0 and 1.</li></ul><p><strong>Outputs</strong></p><ul><li><code>infos::Piecewise2DLineType{T}</code>: an internal datatype for use with <code>evalpiecewise2Dlinearfunc()</code> to evaluate the generated piecewise-linear functions.</li></ul><p>For example, the following creates an anonymous function for the m-th piecewise-linear function:</p><pre><code class="nohighlight hljs">info = infos[m]
f = xx-&gt;evalpiecewise2Dlinearfunc(xx, info)
f_evals = f.(LinRange(p_lb, p_ub, 200))</code></pre><p>Note the usual <code>scale</code> input to <code>evalpiecewise2Dlinearfunc()</code> is not required for the piecewise-linear functions returned by <code>createendopiewiselines1()</code>.</p><ul><li><code>zs::Vector{Vector{T}}</code>: For a given index m in <code>zs</code>, </li></ul><p><code>first(zs[m])</code> is the range coordinate of the start of the focus interval for the m-th piecewise-linear function. <code>last(zs[m])</code> is the range coordinate of the end of the focus interval for the m-th piecewise-linear function.</p><p>Do the following to the get boundary points of the piecewise-linear function.</p><pre><code class="nohighlight hljs">intervals_y_st = [first(zs[m]);]
intervals_y_fin = [last(zs[m]);]
start_pts, fin_pts, boundary_pts = IntervalMonoFuncs.getboundarypts(intervals_y_st, intervals_y_fin, lb, ub, infos[m], 1.0)</code></pre><ul><li><code>p_range::LinRange{T,Int}</code>: <code>p_range[m]</code> is the range coordinate of the center of the focus interval for the m-th function.</li></ul><p>See <code>/examples/fit_logistic-logit.jl</code> in the package repository and the repository document website for other examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/piece_wise_linear.jl#L339-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.getlogisticprobitparameters" href="#IntervalMonoFuncs.getlogisticprobitparameters"><code>IntervalMonoFuncs.getlogisticprobitparameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getlogisticprobitparameters(infos::Vector{Piecewise2DLineType{T}},
    runoptimfunc::Function;
    N_fit_positions::Int = 15,
    a_lb::T = 0.1,
    a_ub::T = 0.6,
    b_lb::T = -5.0,
    b_ub::T = 5.0,
    a_initial = (a_ub-a_lb)/2,
    b_initial = (b_ub-b_lb)/2) where T &lt;: Real</code></pre><p>Given a set of single-focus interval region piecewise-linear functions&#39; parameters (collectively contained in <code>info</code>), fit the <code>a</code> and <code>b</code> parameters of the logistic-probit function (see <code>evalcompositelogisticprobit</code>) for each piecewise-linear function.</p><p><strong>Inputs</strong></p><ul><li><p><code>infos</code>: obtained from <code>createendopiewiselines1()</code>.</p></li><li><p><code>runoptimfunc</code>: This function runs an optimization routine that the user must supply.</p></li></ul><p><code>IntervalMonoFuncs.jl</code> does not currently ship with any optimization routines, nor does it use third party optimization routines as dependencies. This is done so that the user can have more flexibility to choose the optimization package and tuning parameters.</p><p><code>runoptimfunc</code> should be in the following form:</p><pre><code class="nohighlight hljs">runoptimfunc = (pp0, ff, dff, pp_lb, pp_ub)-&gt;runoptimroutine(pp0, ff, dff, pp_lb, pp_ub, other_args...)</code></pre><p>where <code>runoptimroutine()</code> is the user-supplied routine for invoking their box-constrained numerical minimization code of choice. The other optimization package-specific tuning parameters can go where <code>other_args...</code> is. <code>runoptimfunc()</code> should return a <code>Vector{T}</code> that contains the solution to the numerical minimization of <code>ff</code>.</p><p>The <code>pp0::Vector{T}</code> input slot is the optimization variable initial guess slot. the <code>ff::Function</code> slot is for the cost function, It should be such that <code>ff(pp0)</code> is the cost associated with the initial guess. the <code>dff::Function</code> slot is for the gradient of the cost function, It should be such that <code>dff(pp0</code> is the gradient of the cost function evaluated at the initial guess, but one can assign it any function (such as the identity <code>xx-&gt;xx</code>) if they are not using a gradient-based optimization algorithm in their <code>runoptimfunc()</code>. the <code>pp_lb::Vector{T}</code> slot is for the lower bounds of the optimization variable, the <code>pp_ub::Vector{T}</code> slot is for the upper bounds of the variable.</p><p><code>runoptimfunc()</code> must return a 1D array of type <code>Vector{T}</code>, where <code>T = eltype(pp0)</code>.</p><p>There are examples on how to create a valid <code>runoptimfunc</code> on the repository documentation website and in <code>/examples/fit_logistic-logit.jl</code>.</p><p><strong>Optional inputs:</strong></p><ul><li>N<em>fit</em>positions: The number of fit positions used in the optimization.</li><li><code>a_lb</code>: lower bound used for optimizing <code>a</code></li><li><code>a_ub</code>: lower bound used for optimizing <code>a</code></li><li><code>b_lb</code>: lower bound used for optimizing <code>b</code></li><li><code>b_ub</code>: lower bound used for optimizing <code>b</code></li><li><code>a_initial</code>: initial guess for <code>a</code></li><li><code>b_initial</code>: initial guess for <code>b</code></li></ul><p><strong>Outputs (in order):</strong></p><ul><li><code>costfuncs::Vector{Function}</code>: the costfunction used to optimize each logistic-probit function against its corresponding piecewise-linear function.</li><li><code>minxs::Vector{Vector{T}}</code>: 1-D array of solution arrays.</li></ul><p><code>first(minxs[m])</code> is the optimized <code>a</code> variable for the m-th logistic-probit function. <code>last(minxs[m])</code> is the optimized <code>b</code> variable for the m-th logistic-probit function.</p><p>Usage for <code>minxs</code>: The following creates a vector of functions, each implements a fitted logistic-probit function.</p><pre><code class="nohighlight hljs">qs = collect( tt-&gt;IntervalMonoFuncs.evalcompositelogisticprobit(tt, first(minxs[i]), last(minxs[i])) for i in eachindex(minxs) )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/fit/fit_to_linear.jl#L67-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.evalcompositelogisticprobit" href="#IntervalMonoFuncs.evalcompositelogisticprobit"><code>IntervalMonoFuncs.evalcompositelogisticprobit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evalcompositelogisticprobit(x::T, a::T, b::T)::T where T &lt;: Real</code></pre><p>evaluates the map from <code>(0,1)</code> to <code>(0,1)</code>. returns <code>1/(1 + exp(-a*(log(x/(1-x))-b)))</code></p><p>Some numerical stability issues when the magnitudes of <code>a</code> or <code>b</code> is larger than 2 when <code>T = Float64</code>. See <code>/examples/logistic-probit.jl</code> for an example of stability test in the root package directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/composite_sigmoid.jl#L17-L24">source</a></section><section><div><pre><code class="nohighlight hljs">evalcompositelogisticprobit(x_inp::T, a::T, b::T, lb::T, ub::T)::T where T &lt;: Real</code></pre><p>Applies the following:</p><ul><li>Transforms <code>y</code> from <code>[lb,ub]</code> to <code>(0,1)</code>.</li><li>evaluates the map, <code>1/(1 + exp(-a*(log(x/(1-x))-b)))</code>, which transforms a value from <code>(0,1)</code> to <code>(0,1)</code>.</li><li>transforms the evaluated map value from <code>(0,1)</code> to <code>[lb,ub]</code>, and returns the result.</li></ul><p>Some numerical stability issues when the magnitudes of <code>a</code> or <code>b</code> is larger than 2 when <code>T = Float64</code>. See <code>/examples/logistic-probit.jl</code> for an example of stability test in the root package directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/composite_sigmoid.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IntervalMonoFuncs.evalinversecompositelogisticprobit" href="#IntervalMonoFuncs.evalinversecompositelogisticprobit"><code>IntervalMonoFuncs.evalinversecompositelogisticprobit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evalinversecompositelogisticprobit(y::T, a::T, b::T)::T where T &lt;: Real</code></pre><p>evaluates the map from <code>(0,1)</code> to <code>(0,1)</code>. return <code>exp(b)/(exp(b) + (-1 + 1/y)^(1/a))</code></p><p>Some numerical stability issues when the magnitudes of <code>a</code> or <code>b</code> is larger than 2 when <code>T = Float64</code>. See <code>/examples/logistic-probit.jl</code> for an example of stability test in the root package directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/composite_sigmoid.jl#L49-L56">source</a></section><section><div><pre><code class="nohighlight hljs">evalinversecompositelogisticprobit(y::T, a::T, b::T)::T where T &lt;: Real</code></pre><p>Applies the following:</p><ul><li>Transforms <code>y</code> from <code>[lb,ub]</code> to <code>(0,1)</code>.</li><li>evaluates the map, <code>exp(b)/(exp(b) + (-1 + 1/y)^(1/a))</code>, which transforms a value from <code>(0,1)</code> to <code>(0,1)</code>.</li><li>transforms the evaluated map value from <code>(0,1)</code> to <code>[lb,ub]</code>, and returns the result.</li></ul><p>Some numerical stability issues when the magnitudes of <code>a</code> or <code>b</code> is larger than 2 when <code>T = Float64</code>. See <code>/examples/logistic-probit.jl</code> for an example of stability test in the root package directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoyCCWang/IntervalMonoFuncs.jl/blob/91a18fe2b4b91d01b75c9637d9759cbb7322c4ec/src/endomorphisms/composite_sigmoid.jl#L61-L70">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="citation.html">License »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 15 October 2022 18:16">Saturday 15 October 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
